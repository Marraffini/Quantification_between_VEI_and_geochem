---
title: "andesitic rocks"
output: html_document
date: "2025-04-27"
---
```{r}
library(readxl)
library(tidyverse)
library(data.table)
library(ggplot2)
library(GGally)
library(corrplot)
library(recipes)
library(caret)
library(stats)
library(car)
library(broom)
library(MASS)
library(janitor)
library(dplyr)
library(readr)

```


My idea is to delete the rows at the end of the csv because it is only the references, and it might be more difficult later for the binding if I don't remove it now.

I have checked for most of th csv, it all have the same line "Download from GEOROC - Geochemical Database" before the references begin. 
So I thought I would delete all the rows below this line (and this line included).
But it is difficult to just use a delete rows, because the references are written all in a cell.

I think I can do it with readLines : I transform all the csv in text.
After that, it is easier to search for a specific line in the text, here it is "Download from GEOROC - Geochemical Database".


```{r}

andesitic_rocks_dtb_csv = "/Users/annad/Documents/NZ Internship/all georoc databases/andesitic rocks"
andesitic_rocks_dtb_csv2 = "/Users/annad/Documents/NZ Internship/all georoc databases/andesitic rocks/csv2"

csv = list.files(andesitic_rocks_dtb_csv, pattern = "\\.csv$")
csv2 = list.files(andesitic_rocks_dtb_csv2, pattern = "\\.csv$")


print(csv)
print(csv2)


csv_path = file.path(andesitic_rocks_dtb_csv, csv)
csv2_path = file.path(andesitic_rocks_dtb_csv2, csv2)

# --- keep the rows above the references ---

trim_rocks_csv = function(x){
  csv_rock <- read_csv(x, show_col_types = FALSE)
  stop_row <- which(grepl("Download from GEOROC", csv_rock[[1]], ignore.case = TRUE))
  print(stop_row)
  database <- csv_rock[1:(stop_row - 1), ]
}

trim_rocks_csv2 = function(x){
  csv_rock <- read_csv2(x, show_col_types = FALSE)
  stop_row <- which(grepl("Download from GEOROC", csv_rock[[1]], ignore.case = TRUE))
  print(stop_row)
  database <- csv_rock[1:(stop_row - 1), ]
}

andesitic_rocks_csv = lapply(csv_path, trim_rocks_csv)
andesitic_rocks_csv2 = lapply(csv2_path, trim_rocks_csv2)

csv_name = sub("\\.csv$", "", csv)
csv2_name = sub("\\.csv$", "", csv2)

names(andesitic_rocks_csv) = csv_name
names(andesitic_rocks_csv2) = csv2_name

andesitic_rocks = c(andesitic_rocks_csv, andesitic_rocks_csv2)
length(andesitic_rocks)
names(andesitic_rocks)


sapply(andesitic_rocks, nrow)
sapply(andesitic_rocks, head)

```



# --- keep the references ---


```{r}

references_csv <- function(x) {
  csv_rock <- read_csv(x, show_col_types = FALSE)
  stop_row <- which(grepl("References:", csv_rock[[1]], ignore.case = TRUE))
  print(stop_row)
  database <- csv_rock[stop_row:nrow(csv_rock), ]
  return(database)
}

references_csv2 <- function(x) {
  csv_rock <- read_csv2(x, show_col_types = FALSE)
  stop_row <- which(grepl("References:", csv_rock[[1]], ignore.case = TRUE))
  print(stop_row)
  database <- csv_rock[stop_row:nrow(csv_rock), ]
  return(database)
}

andesitic_references_csv = lapply(csv_path, references_csv)
andesitic_references_csv2 = lapply(csv2_path, references_csv2)

csv_name = sub("\\.csv$", "", csv)
csv2_name = sub("\\.csv$", "", csv2)

names(andesitic_references_csv) = csv_name
names(andesitic_references_csv2) = csv2_name

andesitic_references = c(andesitic_references_csv, andesitic_references_csv2)

#sapply(andesitic_references, nrow)
lapply(andesitic_references, head)

#View(andesitic_references$adakit)
```



Let's keep the rows between References (included) and Criteria (excluded) in the csv of references.


Don't run if you don't need the references in this rmd.
```{r}

keep_between_references_criteria <- function(df) {
  #csv_ref <- read_csv(x, show_col_types = FALSE)
  ref_row <- which(grepl("References", df[[1]], ignore.case = TRUE))
  crit_row <- which(grepl("Criteria", df[[1]], ignore.case = TRUE))
  database <- df[ref_row:(crit_row - 1), ]
  return(database)
}


andesitic_references = lapply(andesitic_references, keep_between_references_criteria)


sapply(andesitic_references, head)

#View(andesitic_references$adakit)

#View(andesitic_references$tahitit)

```



Let's drop the columns we don't need.

```{r}

#tail(andesitic_references$tahitit)

#lapply(andesitic_references, class)

andesitic_references = lapply(andesitic_references, function(df) {
  df %>% dplyr::select("Year")
})

#View(andesitic_references$tahitit)


```



I want to bind all the references from andesitic rocks together.

```{r}

# on va juste renommer andesitic_references entre chosen car je veux utiliser ce nom pour le csv 

references_andesitic = andesitic_references

andesitic_references = bind_rows(references_andesitic, .id = "SOURCE")


```


Let's delete the rows where "References:" appear.

```{r}

andesitic_references <- andesitic_references %>%
  filter(!grepl("References:", Year, ignore.case = TRUE))

```



Let's rename the column Year in References.

```{r}

andesitic_references <- andesitic_references %>%
  rename(REFERENCES = Year)


```



Let's remove any NA.

```{r}

andesitic_references <- andesitic_references %>%
  filter(!is.na(REFERENCES) & str_trim(REFERENCES) != "")


```



Let's create a new column named CITATION_ID, that takes the number of the reference of each row.

```{r}

andesitic_references <- andesitic_references %>%
  mutate(CITATION_ID = str_extract(REFERENCES, "\\[(\\d+)\\]"),
         CITATION_ID = str_remove_all(CITATION_ID, "\\[|\\]"))


```





Let's write the csv.

```{r}

#write.csv(andesitic_references, file = "/Users/annad/Documents/NZ Internship/references/andesitic rocks/andesitic_references.csv", row.names = FALSE)

```






We are done for now with the references, let's work on the volcano data, the rows we kept before References.



Now, columns to keep.

```{r}

oxide <- c("SIO2(WT%)", "TIO2(WT%)", "AL2O3(WT%)", "FEOT(WT%)", "FEO(WT%)", "FE2O3T(WT%)", "FE2O3(WT%)",
                 "CAO(WT%)", "MGO(WT%)", "MNO(WT%)", "K2O(WT%)", "NA2O(WT%)", "P2O5(WT%)", "LOI(WT%)")

columns <- c("YEAR", "CITATION", "SAMPLE NAME", "UNIQUE_ID", "LOCATION", "LOCATION COMMENT",
                  "LATITUDE (MIN.)", "LONGITUDE (MIN.)",
                  "LATITUDE (MAX.)", "LONGITUDE (MAX.)",
                  "LAND/SEA (SAMPLING)", "ROCK TYPE", "ROCK NAME",
                  "GEOLOGICAL AGE", "ERUPTION YEAR", "TYPE OF MATERIAL")

columns_to_keep <- c(columns, oxide)




# I want to create a function that select the columns to keep (the lists above).

select_columns <- function(df, keep) { # arguments are dataframe (the ones in the list andesitic_rocks) and keep (vector to indicate the columns to keep in the df)
  current_names <- names(df)   # get the list of the current column names in the dataframe
  matched_cols <- current_names[tolower(current_names) %in% tolower(keep)]
  # compare the current names with the list we want to keep.
  # ignore upper and lower case differences.
  # only select the columns that exist both in the dataframe and in our keep list
  df = df[, matched_cols, drop = FALSE]
  df
}




andesitic_rocks <- lapply(andesitic_rocks, select_columns, keep = columns_to_keep)

colnames(andesitic_rocks$adakit)


```


We force the columns to be the same type.

```{r}

andesitic_rocks <- lapply(andesitic_rocks, function(df) { # function(df) is the if...
  
  if ("SIO2(WT%)" %in% names(df)) {
    df$`SIO2(WT%)` <- as.numeric(gsub(",", ".", df$`SIO2(WT%)`))
  }
  
  if ("TIO2(WT%)" %in% names(df)) {
    df$`TIO2(WT%)` <- as.numeric(gsub(",", ".", df$`TIO2(WT%)`))
  }
  
  if ("AL2O3(WT%)" %in% names(df)) {
    df$`AL2O3(WT%)` <- as.numeric(gsub(",", ".", df$`AL2O3(WT%)`))
  }
  
  if ("FEOT(WT%)" %in% names(df)) {
    df$`FEOT(WT%)` <- as.numeric(gsub(",", ".", df$`FEOT(WT%)`))
  }
  
  if ("FE2O3T(WT%)" %in% names(df)) {
    df$`FE2O3T(WT%)` <- as.numeric(gsub(",", ".", df$`FE2O3T(WT%)`))
  }
  if ("FE2O3(WT%)" %in% names(df)) {
    df$`FE2O3(WT%)` <- as.numeric(gsub(",", ".", df$`FE2O3(WT%)`))
  }
  if ("FEO(WT%)" %in% names(df)) {
    df$`FEO(WT%)` <- as.numeric(gsub(",", ".", df$`FEO(WT%)`))
  }
  
  if ("CAO(WT%)" %in% names(df)) {
    df$`CAO(WT%)` <- as.numeric(gsub(",", ".", df$`CAO(WT%)`))
  }
  
  if ("MGO(WT%)" %in% names(df)) {
    df$`MGO(WT%)` <- as.numeric(gsub(",", ".", df$`MGO(WT%)`))
  }
  
  if ("MNO(WT%)" %in% names(df)) {
    df$`MNO(WT%)` <- as.numeric(gsub(",", ".", df$`MNO(WT%)`))
  }
  
  if ("K2O(WT%)" %in% names(df)) {
    df$`K2O(WT%)` <- as.numeric(gsub(",", ".", df$`K2O(WT%)`))
  }
  
  if ("NA2O(WT%)" %in% names(df)) {
    df$`NA2O(WT%)` <- as.numeric(gsub(",", ".", df$`NA2O(WT%)`))
  }
  
  if ("P2O5(WT%)" %in% names(df)) {
    df$`P2O5(WT%)` <- as.numeric(gsub(",", ".", df$`P2O5(WT%)`))
  }
  
  if ("LOI(WT%)" %in% names(df)) {
    df$`LOI(WT%)` <- as.numeric(gsub(",", ".", df$`LOI(WT%)`))
  }
  
  if ("YEAR" %in% names(df)) {
    df$YEAR <- as.numeric(gsub(",", ".", df$YEAR))
  }
  if ("CITATION" %in% names(df)) {
    df$CITATION <- as.character(df$CITATION)
  }
  if ("UNIQUE_ID" %in% names(df)) {
    df$UNIQUE_ID <- as.numeric(gsub(",", ".", df$UNIQUE_ID))
  }
  
  if ("SAMPLE NAME" %in% names(df)) {
    df$`SAMPLE NAME` <- as.character(df$`SAMPLE NAME`)
  }
  
  if ("LOCATION" %in% names(df)) {
    df$LOCATION <- as.character(df$LOCATION)
  }
  
  if ("LOCATION COMMENT" %in% names(df)) {
    df$`LOCATION COMMENT` <- as.character(df$`LOCATION COMMENT`)
  }
  
  if ("LATITUDE (MIN.)" %in% names(df)) {
    df$`LATITUDE (MIN.)` <- as.numeric(gsub(",", ".", df$`LATITUDE (MIN.)`))
  }
  
  if ("LATITUDE (MAX.)" %in% names(df)) {
    df$`LATITUDE (MAX.)` <- as.numeric(gsub(",", ".", df$`LATITUDE (MAX.)`))
  }
  
  if ("LONGITUDE (MIN.)" %in% names(df)) {
    df$`LONGITUDE (MIN.)` <- as.numeric(gsub(",", ".", df$`LONGITUDE (MIN.)`))
  }
  
  if ("LONGITUDE (MAX.)" %in% names(df)) {
    df$`LONGITUDE (MAX.)` <- as.numeric(gsub(",", ".", df$`LONGITUDE (MAX.)`))
  }
  
  if ("LAND/SEA (SAMPLING)" %in% names(df)) {
    df$`LAND/SEA (SAMPLING)` <- as.character(df$`LAND/SEA (SAMPLING)`)
  }
  
  if ("ROCK NAME" %in% names(df)) {
    df$`ROCK NAME` <- as.character(df$`ROCK NAME`)
  }
  
  if ("ROCK TYPE" %in% names(df)) {
    df$`ROCK TYPE` <- as.character(df$`ROCK TYPE`)
  }
  
  if ("GEOLOGICAL AGE" %in% names(df)) {
    df$`GEOLOGICAL AGE` <- as.character(df$`GEOLOGICAL AGE`)
  }
  
  if ("ERUPTION YEAR" %in% names(df)) {
    df$`ERUPTION YEAR` <- as.character(df$`ERUPTION YEAR`)
  }
  
  if ("TYPE OF MATERIAL" %in% names(df)) {
    df$`TYPE OF MATERIAL` <- as.character(df$`TYPE OF MATERIAL`)
  }
  
  return(df)
})


```





Let's bind the csv.

```{r}

andesitic <- bind_rows(andesitic_rocks, .id = "SOURCE")
# we bind the csv and create a column in the csv so we know from which csv the rows came from

length(andesitic)

head(andesitic)

nrow(andesitic) # we verify if this matches with the sum we calculated before 



andesitic_rocks_tri = andesitic %>%
  dplyr::filter(
  grepl("subaerial", `LAND/SEA (SAMPLING)`, ignore.case = TRUE),
  grepl("volcanic rock", `ROCK TYPE`, ignore.case = TRUE),
  grepl("whole rock", `TYPE OF MATERIAL`, ignore.case = TRUE),
  !grepl("dike", `LOCATION COMMENT`, ignore.case = TRUE),
  !grepl("dyke", `LOCATION COMMENT`, ignore.case = TRUE),
  !grepl("dike", `SAMPLE NAME`, ignore.case = TRUE),
  !grepl("dyke", `SAMPLE NAME`, ignore.case = TRUE),
  !grepl("dikes", `LOCATION COMMENT`, ignore.case = TRUE),
  !grepl("dykes", `LOCATION COMMENT`, ignore.case = TRUE),
  !grepl("dikes", `SAMPLE NAME`, ignore.case = TRUE),
  !grepl("dykes", `SAMPLE NAME`, ignore.case = TRUE),
  !grepl("dikes", `LOCATION`, ignore.case = TRUE),
  !grepl("dykes", `LOCATION`, ignore.case = TRUE),
  !grepl("dike", `LOCATION`, ignore.case = TRUE),
  !grepl("dyke", `LOCATION`, ignore.case = TRUE)
  
  )


# no need
#write.csv(andesitic, file = "/Users/annad/Desktop/NZ Internship/georoc rock databases/andesitic_rocks.csv", row.names = FALSE)
# we create a new csv containing all the csv from andesitic rocks 

```

andesitic_rocks_tri has only the major oxides and the citations.



Formulas for FeOT :

FeOT = FeO + (Fe2O3 x 0.8998)
FeOT = Fe2O3T x 0.8998 


#when all the df are bind

```{r}


class(andesitic_rocks_tri)


andesitic_rocks_tri_sum_fe = andesitic_rocks_tri %>% 
  mutate(sum_fe =
           case_when(
            !is.na(`FEOT(WT%)`) ~ `FEOT(WT%)`,
            is.na(`FEOT(WT%)`) & !is.na(`FEO(WT%)`) & !is.na(`FE2O3(WT%)`) ~ `FEO(WT%)` + (`FE2O3(WT%)` * 0.8998),
            is.na(`FEOT(WT%)`) & is.na(`FEO(WT%)`) & is.na(`FE2O3(WT%)`)  ~ `FE2O3T(WT%)` * 0.8998  ) )                         
    

```



andesitic_rocks_tri_sum_fe is the same as andesitic_rocks_tri but with the column sum_fe in addition. 




Let's create a column that adds up all the oxides except LOI.

--> The problem is that I have all four irons : FeO, FeOT, Fe2O3, Fe2O3T. Total will be more than 100%.
So I need to only take one of the total. HERE I WILL TAKE FEOT.

update 05/05/2025

see code up, I created a column sum_fe that has the total of fe depending on the four iron oxides, using those formulas :
FeOT = FeO + (Fe2O3 x 0.8998)
FeOT = Fe2O3T x 0.8998


```{r}

oxide_with_only_feot <- c("SIO2(WT%)", "TIO2(WT%)", "AL2O3(WT%)", "sum_fe", "CAO(WT%)", "MGO(WT%)", "MNO(WT%)", "K2O(WT%)", "NA2O(WT%)", "P2O5(WT%)")

andesitic_ref_tot_oxides <- andesitic_rocks_tri_sum_fe

andesitic_ref_tot_oxides$`Sum Oxides` <- rowSums(andesitic_ref_tot_oxides[, oxide_with_only_feot], na.rm = TRUE)



# we are going to drop the Fe, we don't need it anymore since we have sum_fe

library(dplyr)

andesitic_ref_tot_oxides = andesitic_ref_tot_oxides %>% dplyr::select(-c("FEOT(WT%)", "FEO(WT%)", "FE2O3T(WT%)", "FE2O3(WT%)"))



```


andesitic_ref_tot_oxides is the same as andesitic_rocks_tri_sum_fe but with Sum Oxides in addition and without the Fe.



# pb 02/05/2025 
# DONT RUN CODE
# it filters considering LOI but I don't want to but idk how to resolve this problem
# so i will drop the LOI and put it back after filtering
 actually there is no pb



Let's filter the rows that don't have all oxides complete.


```{r}


# i need andesitic_ref_tot_oxides and filter here.

oxide_without_loi_and_iron <- c("SIO2(WT%)", "TIO2(WT%)", "AL2O3(WT%)", "sum_fe", "CAO(WT%)", "MGO(WT%)", "MNO(WT%)", "K2O(WT%)", "NA2O(WT%)", "P2O5(WT%)")

df <- andesitic_ref_tot_oxides %>%
  mutate(across(all_of(oxide_without_loi_and_iron), ~as.numeric(.)))

andesitic_oxides_complete <- df %>%
  filter(if_all(all_of(oxide_without_loi_and_iron), ~!is.na(.)))

names(andesitic_oxides_complete)
print(andesitic_oxides_complete)

```

Question : i have al2O3 with more than 100%, is that normal ?


andesitic_oxides_complete is the same andesitic_oxides_complete but with all completed oxides.




Let's delete the rows where the geological age is too great.

```{r}

geo_age_to_remove <- c(
  "MIOCENE", "PALEOZOIC", "ARCHEAN", "CRETACEOUS", "CARBONIFEROUS", 
  "DEVONIAN", "OLIGOCENE", "PERMIAN", "NEOGENE", "JURASSIC", 
  "EOCENE", "MESOZOIC", "PLIOCENE", "PALEOCENE", "ORDOVICIAN", 
  "PROTEROZOIC", "CAMBRIAN", "PALEOGENE", "TRIASSIC", 
  "PERMIAN-TRIASSIC", "JURASSIC-CRETACEOUS", "OLIGOCENE-MIOCENE"
)

andesitic_oxides_complete <- andesitic_oxides_complete %>%
  filter(!(`GEOLOGICAL AGE` %in% geo_age_to_remove))


```



As we did for the references, let's create a column CITATION_ID.

```{r}

andesitic_oxides_complete <- andesitic_oxides_complete %>%
  mutate(CITATION_ID = str_extract(CITATION, "\\[(\\d+)\\]"), # CITATION_ID and REFERENCES_ID are the same (normalement)
         CITATION_ID = str_remove_all(CITATION_ID, "\\[|\\]"))

```







Let's group by citation and add the references in andesitic_oxides_complete.

I will regroup the samples with the same citation, and create a csv where I have :

References                  Sample Name           Location                   ...
[001]                       samp. A-001           New Zealand, Taupo
[001]                       samp. A-002           New Zealand, Taupo
                                 .                        .
                                 .                        .
                                 .                        .
[002]                       samp. B-001.          New Zealand, Tanaraki 


I will use the CITATION_ID column.


```{r}

df_ref = read_csv("/Users/annad/Documents/NZ Internship/references/andesitic rocks/andesitic_references.csv", show_col_types = FALSE)


# Séparer par groupes de citation
grouped_list <- split(andesitic_oxides_complete, andesitic_oxides_complete$CITATION_ID)

# Construire les blocs sans ligne-étiquette
final_list <- list()
for (id in names(grouped_list)) {
  block <- grouped_list[[id]]
  
  # Récupérer la référence associée à cet ID
  reference <- df_ref %>%
    filter(CITATION_ID == id) %>%
    pull(REFERENCES) %>%
    unique() %>%
    paste(collapse = "; ")  # en cas de doublons
  
  # Ajouter la colonne References avec la référence sur toutes les lignes
  block$References <- reference
  
  # Réorganiser les colonnes : References à la fin
  block <- block %>% dplyr::select(dplyr::everything(), References)
  
  final_list[[id]] <- block
}

# Combiner tout
final_df <- bind_rows(final_list)

# Voir le résultat
#print(final_df)



andesitic_rocks_all_info = final_df


```


In andesitic_rocks_all_info, we have :
- every information
- sum of fe
- sum of major oxides
- citations
- references
- and it is classified by citation
- and have complete oxides (with the sum of fe)



I need to write the csv.

```{r}
#write.csv(andesitic_rocks_all_info, file = "/Users/annad/Documents/NZ Internship/rocks all info/andesitic_rocks_all_info.csv", row.names = FALSE)
```




Let's see how many unique citation/references we have. 

```{r}


andesitic_rocks_all_info = read_csv("/Users/annad/Documents/NZ Internship/rocks all info/andesitic_rocks_all_info.csv", show_col_types = FALSE)


length(unique(andesitic_rocks_all_info$CITATION)) #468 -> 465
length(andesitic_rocks_all_info$CITATION) #3321 -> 3310

```

We have 468 unique different references. 



Let's filter in the references for andesitic rocks that we are keeping, based on the andesitic_rocks_all_info csv.


```{r}


length(unique(andesitic_references$REFERENCES)) #1498
length(andesitic_references$REFERENCES) #1533

```

Above, I have 1498 unique different references in the references csv. 
After filtering, i should only have 468 references left.


```{r}
# lets create a df

andesitic_only_good_ref = andesitic_references
andesitic_only_good_ref = as.data.frame(andesitic_only_good_ref)

 

unique_ref <- unique(andesitic_rocks_all_info$CITATION_ID)
length(unique_ref)   # 976 normal


andesitic_only_good_ref <- andesitic_references %>% # dataframe
  filter(CITATION_ID %in% unique_ref) %>% 
  distinct(CITATION_ID, .keep_all = TRUE) # DONT FORGET OR ELSE ITS NOT THE SAME LENGTH

length(unique(andesitic_only_good_ref$CITATION_ID)) 
length(andesitic_only_good_ref$CITATION_ID) 

#write then comment
#write.csv(andesitic_only_good_ref, file = "/Users/annad/Documents/NZ Internship/rocks only good ref filtered/andesitic_only_good_ref.csv", row.names = FALSE)

```


andesitic_only_good_ref.csv in this csv, all the references that are kept are the references where the oxides are complete.




update 07/05/2025


So the idea is to filter out the one which are too old, or have no source. 
For the references, keep : 
• Holocene
• Quaternary 
• Pleistocene 
• Delete all other period of time 

Take all the references, put in a singular csv, keep unique, filter with the filters above.


```{r}

keywords <- c("Pliocene", "Miocene", "Oligocene", "Eocene", "Paleocene", 
              "Upper Cretaceous", "Lower Cretaceous", "Upper Jurassic", 
              "Middle Jurassic", "Lower Jurassic", "Upper Triassic", 
              "Middle Triassic", "Lower Triassic", "Lopingian", "Guadalupian", 
              "Cisuralian", "Upper Pennsylvanian", "Middle Pennsylvanian", 
              "Lower Pennsylvanian", "Upper Mississippian", "Middle Mississippian", 
              "Lower Mississippian", "Upper Devonian", "Middle Devonian", 
              "Lower Devonian", "Pridoli", "Ludlow", "Wenlock", "Llandovery", 
              "Upper Ordovician", "Middle Ordovician", "Lower Ordovician", 
              "Furongian", "Miaolingian", "Cambrian Series 2", "Terreneuvian",
              "Neogene", "Paleogene", "Cretaceous", "Jurassic", "Triassic", 
              "Permian", "Carboniferous", "Devonian", "Silurian", "Ordovician", 
              "Cambrian", "Ediacaran", "Cryogenian", "Tonian", "Stenian", 
              "Ectasian", "Calymmian", "Statherian", "Orosirian", "Rhyacian", 
              "Siderian", "Eoarchean", "Paleoarchean", "Mesoarchean", "Neoarchean", 
              "Paleoproterozoic", "Mesoproterozoic", "Neoproterozoic", "Paleozoic")

pattern <- paste(keywords, collapse = "|")

andesitic_only_good_ref_filtered <- andesitic_only_good_ref[!grepl(pattern, andesitic_only_good_ref$REFERENCES, ignore.case = TRUE), ]


#it deletes 40


#write.csv(andesitic_only_good_ref_filtered, file = "/Users/annad/Documents/NZ Internship/rocks only good ref filtered/andesitic_only_good_ref_filtered.csv", row.names = FALSE)


```










