---
title: "basaltic rocks"
output: html_document
date: "2025-04-27"
---

```{r}
library(readxl)
library(tidyverse)
library(data.table)
library(ggplot2)
library(GGally)
library(corrplot)
library(recipes)
library(caret)
library(stats)
library(car)
library(broom)
library(MASS)
library(janitor)
library(dplyr)
library(readr)

```



```{r}
basaltic_rocks_dtb_csv = "/Users/annad/Documents/NZ Internship/all georoc databases/basaltic rocks/csv"
basaltic_rocks_dtb_csv2 = "/Users/annad/Documents/NZ Internship/all georoc databases/basaltic rocks/csv2"

csv = list.files(basaltic_rocks_dtb_csv, pattern = "\\.csv$")
csv2 = list.files(basaltic_rocks_dtb_csv2, pattern = "\\.csv$")

print(csv)
print(csv2)

csv_path = file.path(basaltic_rocks_dtb_csv, csv)
csv2_path = file.path(basaltic_rocks_dtb_csv2, csv2)

trim_rocks_csv = function(x){
  csv_rock <- read_csv(x, show_col_types = FALSE)
  stop_row <- which(grepl("Download from GEOROC", csv_rock[[1]], ignore.case = TRUE))
  print(stop_row)
  database <- csv_rock[1:(stop_row - 1), ]
}

trim_rocks_csv2 = function(x){
  csv_rock <- read_csv2(x, show_col_types = FALSE)
  stop_row <- which(grepl("Download from GEOROC", csv_rock[[1]], ignore.case = TRUE))
  print(stop_row)
  database <- csv_rock[1:(stop_row - 1), ]
}


basaltic_rocks_csv = lapply(csv_path, trim_rocks_csv)
basaltic_rocks_csv2 = lapply(csv2_path, trim_rocks_csv2)

csv_name = sub("\\.csv$", "", csv)
csv2_name = sub("\\.csv$", "", csv2)

names(basaltic_rocks_csv) = csv_name
names(basaltic_rocks_csv2) = csv2_name

basaltic_rocks = c(basaltic_rocks_csv, basaltic_rocks_csv2)

sapply(basaltic_rocks, nrow)
sapply(basaltic_rocks, head)

#sapply(basaltic_rocks, colnames)
```


keep the references




```{r}

references_csv <- function(x) {
  csv_rock <- read_csv(x, show_col_types = FALSE)
  stop_row <- which(grepl("References:", csv_rock[[1]], ignore.case = TRUE))
  print(stop_row)
  database <- csv_rock[stop_row:nrow(csv_rock), ]
  return(database)
}

references_csv2 <- function(x) {
  csv_rock <- read_csv2(x, show_col_types = FALSE)
  stop_row <- which(grepl("References:", csv_rock[[1]], ignore.case = TRUE))
  print(stop_row)
  database <- csv_rock[stop_row:nrow(csv_rock), ]
  return(database)
}

basaltic_references_csv = lapply(csv_path, references_csv)
basaltic_references_csv2 = lapply(csv2_path, references_csv2)

csv_name = sub("\\.csv$", "", csv)
csv2_name = sub("\\.csv$", "", csv2)

names(basaltic_references_csv) = csv_name
names(basaltic_references_csv2) = csv2_name

basaltic_references = c(basaltic_references_csv, basaltic_references_csv2)

lapply(basaltic_references, head)

```



Let's keep the rows between References (included) and Criteria (excluded) in the csv of references.


Don't run if you don't need the references in this rmd.
```{r}

keep_between_references_criteria <- function(df) {
  #csv_ref <- read_csv(x, show_col_types = FALSE)
  ref_row <- which(grepl("References", df[[1]], ignore.case = TRUE))
  crit_row <- which(grepl("Criteria", df[[1]], ignore.case = TRUE))
  database <- df[ref_row:(crit_row - 1), ]
  return(database)
}


basaltic_references = lapply(basaltic_references, keep_between_references_criteria)


sapply(basaltic_references, head)


#View(basaltic_references$tephrit)

```



Let's drop the columns we don't need.

```{r}



basaltic_references = lapply(basaltic_references, function(df) {
  df %>% dplyr::select("Year")
})



```



I want to bind all the references from basaltic rocks together.

```{r}

# on va juste renommer basaltic_references entre chosen car je veux utiliser ce nom pour le csv 

references_basaltic = basaltic_references

basaltic_references = bind_rows(references_basaltic, .id = "SOURCE")


```


Let's delete the rows where "References:" appear.

```{r}

basaltic_references <- basaltic_references %>%
  filter(!grepl("References:", Year, ignore.case = TRUE))

```



Let's rename the column Year in References.

```{r}

basaltic_references <- basaltic_references %>%
  rename(REFERENCES = Year)


```



Let's remove any NA.

```{r}

basaltic_references <- basaltic_references %>%
  filter(!is.na(REFERENCES) & str_trim(REFERENCES) != "")


```



Let's create a new column named CITATION_ID, that takes the number of the reference of each row.

```{r}

basaltic_references <- basaltic_references %>%
  mutate(CITATION_ID = str_extract(REFERENCES, "\\[(\\d+)\\]"),
         CITATION_ID = str_remove_all(CITATION_ID, "\\[|\\]"))


```





Let's write the csv.

```{r}

#write.csv(basaltic_references, file = "/Users/annad/Documents/NZ Internship/references/basaltic rocks/basaltic_references.csv", row.names = FALSE)

```





We are done for now with the references, let's work on the volcano data, the rows we kept before References.






```{r}

oxide <- c("SIO2(WT%)", "TIO2(WT%)", "AL2O3(WT%)", "FEOT(WT%)", "FEO(WT%)", "FE2O3T(WT%)", "FE2O3(WT%)",
                 "CAO(WT%)", "MGO(WT%)", "MNO(WT%)", "K2O(WT%)", "NA2O(WT%)", "P2O5(WT%)", "LOI(WT%)")

columns <- c("YEAR", "CITATION", "SAMPLE NAME", "UNIQUE_ID", "LOCATION", "LOCATION COMMENT",
                  "LATITUDE (MIN.)", "LONGITUDE (MIN.)",
                  "LATITUDE (MAX.)", "LONGITUDE (MAX.)",
                  "LAND/SEA (SAMPLING)", "ROCK TYPE", "ROCK NAME",
                  "GEOLOGICAL AGE", "ERUPTION YEAR", "TYPE OF MATERIAL")


columns_to_keep <- c(columns, oxide)



select_relevant_columns <- function(df, keep) {
  current_names <- names(df)
  matched_cols <- current_names[tolower(current_names) %in% tolower(keep)]
  df[, matched_cols, drop = FALSE]
}

basaltic_rocks <- lapply(basaltic_rocks, select_relevant_columns, keep = columns_to_keep)

colnames(basaltic_rocks$basanit)


```


We force the columns to be the same type.

```{r}


basaltic_rocks <- lapply(basaltic_rocks, function(df) {
  
  if ("SIO2(WT%)" %in% names(df)) {
    df$`SIO2(WT%)` <- as.numeric(gsub(",", ".", df$`SIO2(WT%)`))
  }
  
  if ("TIO2(WT%)" %in% names(df)) {
    df$`TIO2(WT%)` <- as.numeric(gsub(",", ".", df$`TIO2(WT%)`))
  }
  
  if ("AL2O3(WT%)" %in% names(df)) {
    df$`AL2O3(WT%)` <- as.numeric(gsub(",", ".", df$`AL2O3(WT%)`))
  }
  
  if ("FEOT(WT%)" %in% names(df)) {
    df$`FEOT(WT%)` <- as.numeric(gsub(",", ".", df$`FEOT(WT%)`))
  }
  
  if ("FE2O3T(WT%)" %in% names(df)) {
    df$`FE2O3T(WT%)` <- as.numeric(gsub(",", ".", df$`FE2O3T(WT%)`))
  }
  if ("FE2O3(WT%)" %in% names(df)) {
    df$`FE2O3(WT%)` <- as.numeric(gsub(",", ".", df$`FE2O3(WT%)`))
  }
  if ("FEO(WT%)" %in% names(df)) {
    df$`FEO(WT%)` <- as.numeric(gsub(",", ".", df$`FEO(WT%)`))
  }
  
  if ("CAO(WT%)" %in% names(df)) {
    df$`CAO(WT%)` <- as.numeric(gsub(",", ".", df$`CAO(WT%)`))
  }
  
  if ("MGO(WT%)" %in% names(df)) {
    df$`MGO(WT%)` <- as.numeric(gsub(",", ".", df$`MGO(WT%)`))
  }
  
  if ("MNO(WT%)" %in% names(df)) {
    df$`MNO(WT%)` <- as.numeric(gsub(",", ".", df$`MNO(WT%)`))
  }
  
  if ("K2O(WT%)" %in% names(df)) {
    df$`K2O(WT%)` <- as.numeric(gsub(",", ".", df$`K2O(WT%)`))
  }
  
  if ("NA2O(WT%)" %in% names(df)) {
    df$`NA2O(WT%)` <- as.numeric(gsub(",", ".", df$`NA2O(WT%)`))
  }
  
  if ("P2O5(WT%)" %in% names(df)) {
    df$`P2O5(WT%)` <- as.numeric(gsub(",", ".", df$`P2O5(WT%)`))
  }
  
  if ("LOI(WT%)" %in% names(df)) {
    df$`LOI(WT%)` <- as.numeric(gsub(",", ".", df$`LOI(WT%)`))
  }
  
  if ("YEAR" %in% names(df)) {
    df$YEAR <- as.numeric(gsub(",", ".", df$YEAR))
  }
  if ("CITATION" %in% names(df)) {
    df$CITATION <- as.character(df$CITATION)
  }
  if ("UNIQUE_ID" %in% names(df)) {
    df$UNIQUE_ID <- as.numeric(gsub(",", ".", df$UNIQUE_ID))
  }
  
  if ("SAMPLE NAME" %in% names(df)) {
    df$`SAMPLE NAME` <- as.character(df$`SAMPLE NAME`)
  }
  
  if ("LOCATION" %in% names(df)) {
    df$LOCATION <- as.character(df$LOCATION)
  }
  
  if ("LOCATION COMMENT" %in% names(df)) {
    df$`LOCATION COMMENT` <- as.character(df$`LOCATION COMMENT`)
  }
  
  if ("LATITUDE (MIN.)" %in% names(df)) {
    df$`LATITUDE (MIN.)` <- as.numeric(gsub(",", ".", df$`LATITUDE (MIN.)`))
  }
  
  if ("LATITUDE (MAX.)" %in% names(df)) {
    df$`LATITUDE (MAX.)` <- as.numeric(gsub(",", ".", df$`LATITUDE (MAX.)`))
  }
  
  if ("LONGITUDE (MIN.)" %in% names(df)) {
    df$`LONGITUDE (MIN.)` <- as.numeric(gsub(",", ".", df$`LONGITUDE (MIN.)`))
  }
  
  if ("LONGITUDE (MAX.)" %in% names(df)) {
    df$`LONGITUDE (MAX.)` <- as.numeric(gsub(",", ".", df$`LONGITUDE (MAX.)`))
  }
  
  if ("LAND/SEA (SAMPLING)" %in% names(df)) {
    df$`LAND/SEA (SAMPLING)` <- as.character(df$`LAND/SEA (SAMPLING)`)
  }
  
  if ("ROCK NAME" %in% names(df)) {
    df$`ROCK NAME` <- as.character(df$`ROCK NAME`)
  }
  
  if ("ROCK TYPE" %in% names(df)) {
    df$`ROCK TYPE` <- as.character(df$`ROCK TYPE`)
  }
  
  if ("GEOLOGICAL AGE" %in% names(df)) {
    df$`GEOLOGICAL AGE` <- as.character(df$`GEOLOGICAL AGE`)
  }
  
  if ("ERUPTION YEAR" %in% names(df)) {
    df$`ERUPTION YEAR` <- as.character(df$`ERUPTION YEAR`)
  }
  
  if ("TYPE OF MATERIAL" %in% names(df)) {
    df$`TYPE OF MATERIAL` <- as.character(df$`TYPE OF MATERIAL`)
  }
  
  return(df)
})



```



Let's bind.


```{r}


basaltic <- bind_rows(basaltic_rocks, .id = "SOURCE")

length(basaltic)

head(basaltic)

nrow(basaltic)

basaltic_rocks_tri = basaltic %>%
  dplyr::filter(
  grepl("subaerial", `LAND/SEA (SAMPLING)`, ignore.case = TRUE),
  grepl("volcanic rock", `ROCK TYPE`, ignore.case = TRUE),
  grepl("whole rock", `TYPE OF MATERIAL`, ignore.case = TRUE),
  !grepl("dike", `LOCATION COMMENT`, ignore.case = TRUE),
  !grepl("dyke", `LOCATION COMMENT`, ignore.case = TRUE),
  !grepl("dike", `SAMPLE NAME`, ignore.case = TRUE),
  !grepl("dyke", `SAMPLE NAME`, ignore.case = TRUE),
  !grepl("dikes", `LOCATION COMMENT`, ignore.case = TRUE),
  !grepl("dykes", `LOCATION COMMENT`, ignore.case = TRUE),
  !grepl("dikes", `SAMPLE NAME`, ignore.case = TRUE),
  !grepl("dykes", `SAMPLE NAME`, ignore.case = TRUE),
  !grepl("dikes", `LOCATION`, ignore.case = TRUE),
  !grepl("dykes", `LOCATION`, ignore.case = TRUE),
  !grepl("dike", `LOCATION`, ignore.case = TRUE),
  !grepl("dyke", `LOCATION`, ignore.case = TRUE)
  
  )

# no need to write
#write.csv(basaltic, file = "/Users/annad/Desktop/NZ Internship/georoc rock databases/basaltic_rocks.csv", row.names = FALSE)


```



basaltic_rocks_tri has only the major oxides and the citations.



Formulas for FeOT :

FeOT = FeO + (Fe2O3 x 0.8998)
FeOT = Fe2O3T x 0.8998 


#when all the df are bind

```{r}


class(basaltic_rocks_tri)
#View(basaltic_rocks_tri)


basaltic_rocks_tri_sum_fe = basaltic_rocks_tri %>% 
  mutate(sum_fe =
           case_when(
            !is.na(`FEOT(WT%)`) ~ `FEOT(WT%)`,
            is.na(`FEOT(WT%)`) & !is.na(`FEO(WT%)`) & !is.na(`FE2O3(WT%)`) ~ `FEO(WT%)` + (`FE2O3(WT%)` * 0.8998),
            is.na(`FEOT(WT%)`) & is.na(`FEO(WT%)`) & is.na(`FE2O3(WT%)`)  ~ `FE2O3T(WT%)` * 0.8998  ) )                         
    

```



basaltic_rocks_tri_sum_fe is the same as basaltic_rocks_tri but with the column sum_fe in addition. 




Let's create a column that adds up all the oxides except LOI.

--> The problem is that I have all four irons : FeO, FeOT, Fe2O3, Fe2O3T. Total will be more than 100%.
So I need to only take one of the total. HERE I WILL TAKE FEOT.

update 05/05/2025

see code up, I created a column sum_fe that has the total of fe depending on the four iron oxides, using those formulas :
FeOT = FeO + (Fe2O3 x 0.8998)
FeOT = Fe2O3T x 0.8998


```{r}

oxide_with_only_feot <- c("SIO2(WT%)", "TIO2(WT%)", "AL2O3(WT%)", "sum_fe", "CAO(WT%)", "MGO(WT%)", "MNO(WT%)", "K2O(WT%)", "NA2O(WT%)", "P2O5(WT%)")

basaltic_ref_tot_oxides <- basaltic_rocks_tri_sum_fe

basaltic_ref_tot_oxides$`Sum Oxides` <- rowSums(basaltic_ref_tot_oxides[, oxide_with_only_feot], na.rm = TRUE)




# we are going to drop the Fe, we don't need it anymore since we have sum_fe

library(dplyr)

basaltic_ref_tot_oxides = basaltic_ref_tot_oxides %>% dplyr::select(-c("FEOT(WT%)", "FEO(WT%)", "FE2O3T(WT%)", "FE2O3(WT%)"))



```


basaltic_ref_tot_oxides is the same as basaltic_rocks_tri_sum_fe but with Sum Oxides in addition and without the Fe.



# pb 02/05/2025 
# DONT RUN CODE
# it filters considering LOI but I don't want to but idk how to resolve this problem
# so i will drop the LOI and put it back after filtering
 actually there is no pb



Let's filter the rows that don't have all oxides complete.


```{r}

# i need basaltic_ref_tot_oxides and filter here.

oxide_without_loi_and_iron <- c("SIO2(WT%)", "TIO2(WT%)", "AL2O3(WT%)", "sum_fe", "CAO(WT%)", "MGO(WT%)", "MNO(WT%)", "K2O(WT%)", "NA2O(WT%)", "P2O5(WT%)")

df <- basaltic_ref_tot_oxides %>%
  mutate(across(all_of(oxide_without_loi_and_iron), ~as.numeric(.)))

basaltic_oxides_complete <- df %>%
  filter(if_all(all_of(oxide_without_loi_and_iron), ~!is.na(.)))

names(basaltic_oxides_complete)
print(basaltic_oxides_complete)

```

Question : i have al2O3 with more than 100%, is that normal ?


basaltic_oxides_complete is the same basaltic_oxides_complete but with all completed oxides.



Let's delete the rows where the geological age is too great.

```{r}

geo_age_to_remove <- c(
  "MIOCENE", "PALEOZOIC", "ARCHEAN", "CRETACEOUS", "CARBONIFEROUS", 
  "DEVONIAN", "OLIGOCENE", "PERMIAN", "NEOGENE", "JURASSIC", 
  "EOCENE", "MESOZOIC", "PLIOCENE", "PALEOCENE", "ORDOVICIAN", 
  "PROTEROZOIC", "CAMBRIAN", "PALEOGENE", "TRIASSIC", 
  "PERMIAN-TRIASSIC", "JURASSIC-CRETACEOUS", "OLIGOCENE-MIOCENE"
)

basaltic_oxides_complete <- basaltic_oxides_complete %>%
  filter(!(`GEOLOGICAL AGE` %in% geo_age_to_remove))


```




As we did for the references, let's create a column CITATION_ID.

```{r}

basaltic_oxides_complete <- basaltic_oxides_complete %>%
  mutate(CITATION_ID = str_extract(CITATION, "\\[(\\d+)\\]"), # CITATION_ID and REFERENCES_ID are the same (normalement)
         CITATION_ID = str_remove_all(CITATION_ID, "\\[|\\]"))

```





Let's group by citation and add the references.
I will regroup the samples with the same citation, and create a csv where I have :

References                  Sample Name           Location                   ...
[001]                       samp. A-001           New Zealand, Taupo
[001]                       samp. A-002           New Zealand, Taupo
                                 .                        .
                                 .                        .
                                 .                        .
[002]                       samp. B-001.          New Zealand, Tanaraki 



```{r}

df_ref = read_csv("/Users/annad/Documents/NZ Internship/references/basaltic rocks/basaltic_references.csv", show_col_types = FALSE)

# Séparer par groupes de citation
grouped_list <- split(basaltic_oxides_complete, basaltic_oxides_complete$CITATION_ID)

# Construire les blocs sans ligne-étiquette
final_list <- list()
for (id in names(grouped_list)) {
  block <- grouped_list[[id]]
  
  # Récupérer la référence associée à cet ID
  reference <- df_ref %>%
    filter(CITATION_ID == id) %>%
    pull(REFERENCES) %>%
    unique() %>%
    paste(collapse = "; ")  # en cas de doublons
  
  # Ajouter la colonne References avec la référence sur toutes les lignes
  block$References <- reference
  
  # Réorganiser les colonnes : References à la fin
  block <- block %>% dplyr::select(dplyr::everything(), References)
  
  final_list[[id]] <- block
}

# Combiner tout
final_df <- bind_rows(final_list)

# Voir le résultat
#print(final_df)



basaltic_rocks_all_info = final_df


```


In final_df, we have :
- every information
- sum of fe
- sum of major oxides
- citations
- references
- and it is classified by citation
- and have complete oxides (with the sum of fe)




I need to write the csv.

```{r}
#write.csv(final_df, file = "/Users/annad/Documents/NZ Internship/rocks all info/basaltic_rocks_all_info.csv", row.names = FALSE)
```




Let's see how many unique citation we have. 

```{r}


basaltic_rocks_all_info = read_csv("/Users/annad/Documents/NZ Internship/rocks all info/basaltic_rocks_all_info.csv", show_col_types = FALSE)


length(unique(basaltic_rocks_all_info$References)) #836 -> 828
length(basaltic_rocks_all_info$References) #6255 -> 6209

```





Let's filter in the references for basaltic rocks that we are keeping, based on the basaltic_rocks_all_info.csv.




```{r}


length(unique(basaltic_references$REFERENCES)) #4029
length(basaltic_references$REFERENCES) #5905

```

Above, I have 4029 unique different references in the references csv. 
After filtering, i should only have 836 references left.


```{r}
# lets create a df

basaltic_only_good_ref = basaltic_references
basaltic_only_good_ref = as.data.frame(basaltic_only_good_ref)


unique_ref <- unique(basaltic_rocks_all_info$CITATION_ID)
length(unique_ref)   # 836 normal


basaltic_only_good_ref <- basaltic_references %>% # dataframe
  filter(CITATION_ID %in% unique_ref) %>% 
  distinct(CITATION_ID, .keep_all = TRUE) # DONT FORGET OR ELSE ITS NOT THE SAME LENGTH

length(unique(basaltic_only_good_ref$CITATION_ID)) # 836
length(basaltic_only_good_ref$CITATION_ID) #836  


#write then comment
#write.csv(basaltic_only_good_ref, file = "/Users/annad/Documents/NZ Internship/rocks only good ref filtered/basaltic_only_good_ref.csv", row.names = FALSE)

```


basaltic_only_good_ref.csv in this csv, all the references that are kept are the references where the oxides are complete.




update 07/05/2025


So the idea is to filter out the one which are too old, or have no source. 
For the references, keep : 
• Holocene
• Quaternary 
• Pleistocene 
• Delete all other period of time 

Take all the references, put in a singular csv, keep unique, filter with the filters above.


```{r}

keywords <- c("Pliocene", "Miocene", "Oligocene", "Eocene", "Paleocene", 
              "Upper Cretaceous", "Lower Cretaceous", "Upper Jurassic", 
              "Middle Jurassic", "Lower Jurassic", "Upper Triassic", 
              "Middle Triassic", "Lower Triassic", "Lopingian", "Guadalupian", 
              "Cisuralian", "Upper Pennsylvanian", "Middle Pennsylvanian", 
              "Lower Pennsylvanian", "Upper Mississippian", "Middle Mississippian", 
              "Lower Mississippian", "Upper Devonian", "Middle Devonian", 
              "Lower Devonian", "Pridoli", "Ludlow", "Wenlock", "Llandovery", 
              "Upper Ordovician", "Middle Ordovician", "Lower Ordovician", 
              "Furongian", "Miaolingian", "Cambrian Series 2", "Terreneuvian",
              "Neogene", "Paleogene", "Cretaceous", "Jurassic", "Triassic", 
              "Permian", "Carboniferous", "Devonian", "Silurian", "Ordovician", 
              "Cambrian", "Ediacaran", "Cryogenian", "Tonian", "Stenian", 
              "Ectasian", "Calymmian", "Statherian", "Orosirian", "Rhyacian", 
              "Siderian", "Eoarchean", "Paleoarchean", "Mesoarchean", "Neoarchean", 
              "Paleoproterozoic", "Mesoproterozoic", "Neoproterozoic", "Paleozoic")

pattern <- paste(keywords, collapse = "|")

basaltic_only_good_ref_filtered <- basaltic_only_good_ref[!grepl(pattern, basaltic_only_good_ref$REFERENCES, ignore.case = TRUE), ]

# it deletes 38 rows

#write.csv(basaltic_only_good_ref_filtered, file = "/Users/annad/Documents/NZ Internship/rocks only good ref filtered/basaltic_only_good_ref_filtered.csv", row.names = FALSE)


```











